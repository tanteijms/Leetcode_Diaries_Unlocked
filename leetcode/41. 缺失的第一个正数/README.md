# [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)



## 题目

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

 

**提示：**

- $1 <= nums.length <= 10^5$
- $-2^{31} <= nums[i] <= 2^{31} - 1$



## 题解

```cpp
// 空间复杂度O(n)

class Solution
{
public:
    int firstMissingPositive(vector<int> &nums)
    {
        for (int i = 0; i < nums.size(); i++)
        {
            while (1 <= nums[i] && nums[i] <= nums.size() && nums[i] != nums[nums[i] - 1]) // -1确保实际与数组一致，开始不同，1和0
            {
                int a = nums[i] - 1;
                swap(nums[i], nums[a]);
            }
        }
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] - 1 != i)
                return i + 1;
        }
        return nums.size() + 1;
    }
};
```



## points

1. 考虑一个个进行顺序交换，直到所有的数字和它的序号对应

   机制为：对于某个索引i，它的数字是nums[i]，我们需要做的是让他呆在自己的位置上，即nums[i]这个索引上。但由于本题找的范围是1~n，而数组下标是0~n，因此再一一对应的时候，要-1，也就是说，nums[i]应该去到nums[i]-1这个位置上。只要它没有在这个位置上，就交换它。

   如果一个数有重复的数字，只需要让它其中一个在正确的位置上即可

   用nums[i]!=nums[nums[i]-1]来判断

   考虑：

   若只有一个数，那么就是上面所述的，判断它是否在对应的位置上

   若有两个数及以上：

   若没有一个数在对应的位置上，那么在遍历的过程中，一定会找到第一个数，然后把它交换到了正确的位置上

   若已经有一个数在它的位置上了，也就是，nums[i]-1位置上，就是我要的数。所以当比较nums[i]和nums[nums[i]-1]的时候，显然二者是相等的，因此就直接跳过了

   所以这个式子能够很好的处理多种情况。只要想清楚：不是一定要元素一模一样，而是只要值是相等的就可以了，不一定就是那个元素自己，可以是副本，或拷贝

2. 当上述操作做完以后，接下来就是找到第一个不在自己位置上的。如果比如4不存在于nums，那么nums[3]这个数一定不是4，但一定有值，所以我们比较nums[i]与i+1，注意顺序仍旧是错开的

   如果直到nums.end()所有的数都是对应的，那么显然1-n都是有的，此时返回n+1即可

   